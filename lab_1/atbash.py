# Модуль шифра Атбаш (лабораторная 1).
# Содержит все функции для шифрования и расшифрования.

# Алфавит русского языка без буквы "ё" (32 буквы)
RUS_ALPHABET = "абвгдежзийклмнопрстуфхцчшщъыьэюя"


# Создаёт словарь: каждому знаку препинания (.,;:!?- и т.д.) сопоставляется трёх- или четырёхбуквенный код (тчк, зпт, тир и т.д.) для замены при подготовке текста к шифрованию.
def create_punctuation_codes():
    """Словарь замены знаков препинания на трехбуквенные коды."""
    codes = {}
    codes["."] = "тчк"
    codes[","] = "зпт"
    codes[":"] = "двтч"
    codes[";"] = "тчзп"
    codes["!"] = "вскл"
    codes["?"] = "впрс"
    codes["-"] = "тир"
    return codes


# По словарю «знак препинания → код» строит обратный словарь «код → знак препинания»; нужен при расшифровке, чтобы заменять коды (тчк, зпт и т.д.) обратно на точки, запятые и т.д.
def create_code_to_punctuation(punctuation_codes):
    """Обратный словарь: код -> знак препинания."""
    reverse_codes = {}
    # Перебираю каждый знак препинания из исходного словаря
    for znak in punctuation_codes:
        # Получаю соответствующий ему трёхбуквенный код
        kod = punctuation_codes[znak]
        # Записываю обратную пару: по коду восстанавливаю знак
        reverse_codes[kod] = znak
    # Возвращаю обратный словарь для расшифровки
    return reverse_codes


# Готовит строку к шифрованию: переводит в нижний регистр, заменяет «ё» на «е», знаки препинания — на трёхбуквенные коды по переданному словарю, удаляет все пробелы; возвращает одну строку без пробелов.
def prepare_text_for_encryption(text, punctuation_codes):
    """Подготовка текста: нижний регистр, ё->е, знаки в коды, без пробелов."""
    # Перевожу весь текст в нижний регистр
    text = text.lower()
    # Заменяю букву «ё» на «е» по требованию задания
    text = text.replace("ё", "е")
    # Строка, в которую собираю результат без пробелов
    result = ""
    # Прохожу по каждому символу исходного текста
    for symbol in text:
        # Пробелы пропускаю — не добавляю в result
        if symbol == " ":
            continue
        # Если символ — знак препинания, подставляю его трёхбуквенный код
        elif symbol in punctuation_codes:
            result = result + punctuation_codes[symbol]
        # Иначе (буква или другой символ) добавляю как есть
        else:
            result = result + symbol
    # Возвращаю подготовленную строку без пробелов
    return result


# Шифрует строку методом Атбаш для заданного алфавита: каждую букву из алфавита заменяет на зеркальную (первая ↔ последняя, вторая ↔ предпоследняя и т.д.); символы не из алфавита не меняет.
def encrypt_atbash(text, alphabet):
    """Шифрование по методу Атбаш."""
    # Вычисляю длину алфавита для зеркальной позиции
    alphabet_length = len(alphabet)
    # Строка для накопления зашифрованного текста
    encrypted = ""
    # Обрабатываю каждый символ исходного текста
    for symbol in text:
        # Шифрую только буквы из заданного алфавита
        if symbol in alphabet:
            # Начальная позиция буквы в алфавите (найду в цикле)
            position = 0
            # Перебираю индексы алфавита, чтобы найти позицию symbol
            for i in range(alphabet_length):
                # Символ алфавита совпал с текущей буквой
                if alphabet[i] == symbol:
                    # Запоминаю индекс и выхожу из цикла
                    position = i
                    break
            # Зеркальная позиция: с конца алфавита (а↔я, б↔ю и т.д.)
            mirror_position = alphabet_length - 1 - position
            # Беру букву из алфавита по зеркальной позиции
            encrypted_symbol = alphabet[mirror_position]
            # Добавляю зашифрованную букву к результату
            encrypted = encrypted + encrypted_symbol
        # Символ не из алфавита (уже подставленный код) оставляю как есть
        else:
            encrypted = encrypted + symbol
    # Возвращаю полностью зашифрованную строку
    return encrypted


# Разбивает строку на группы по 5 символов и вставляет между группами пробел; последняя группа может быть короче пяти символов.
def split_into_groups_of_five(text):
    """Разбивка текста на группы по 5 символов с пробелами."""
    # Строка для вывода с пробелами между группами
    result = ""
    # Счётчик символов: после каждых 5 ставлю пробел
    counter = 0
    # Иду по каждому символу текста
    for symbol in text:
        # Перед 6-м, 11-м, 16-м и т.д. символом добавляю пробел
        if counter > 0 and counter % 5 == 0:
            result = result + " "
        # Добавляю текущий символ к результату
        result = result + symbol
        # Увеличиваю счётчик на 1
        counter = counter + 1
    # Возвращаю отформатированную строку
    return result


# В строке находит трёх- и четырёхбуквенные коды (тчк, зпт, тир и т.д.) по переданному словарю «код → знак» и заменяет их на соответствующие знаки препинания; остальные символы копирует без изменений.
def restore_punctuation_from_codes(text, code_to_punctuation):
    """Восстановление знаков препинания из кодов."""
    # Строка, в которую собираю текст со знаками препинания
    result = ""
    # Текущая позиция при разборе текста (иду слева направо)
    position = 0
    # Пока не дошёл до конца строки
    while position < len(text):
        # Флаг: нашёл ли я код знака препинания на этой позиции
        code_found = False
        # Перебираю все известные коды (тчк, зпт, тир и т.д.)
        for kod in code_to_punctuation:
            # Длина кода (обычно 3 или 4 символа)
            kod_length = len(kod)
            # Проверяю, что от position вперёд хватает символов для этого кода
            if position + kod_length <= len(text):
                # Вырезаю кусок текста той же длины, что и код
                text_piece = text[position:position + kod_length]
                # Кусок совпал с кодом — это знак препинания
                if text_piece == kod:
                    # Получаю соответствующий знак препинания
                    znak = code_to_punctuation[kod]
                    # Добавляю знак в результат
                    result = result + znak
                    # Сдвигаю позицию вперёд на длину кода (код уже обработан)
                    position = position + kod_length
                    # Запоминаю, что код найден, и выхожу из цикла по кодам
                    code_found = True
                    break
        # Ни один код на этой позиции не подошёл — это обычная буква
        if code_found == False:
            # Добавляю один символ как есть и сдвигаю позицию на 1
            result = result + text[position]
            position = position + 1
    # Возвращаю текст с восстановленными знаками препинания
    return result


# Расшифровывает шифртекст Атбаш: так как шифр симметричный, вызывает encrypt_atbash с теми же аргументами — повторное применение возвращает исходный текст.
def decrypt_atbash(encrypted_text, alphabet):
    """Расшифрование Атбаш (то же действие, что и шифрование)."""
    # Атбаш симметричен: повторное применение возвращает исходный текст
    return encrypt_atbash(encrypted_text, alphabet)


# Функции для использования из main.py: полный цикл шифрования/расшифрования

# Выполняет полный цикл шифрования: подготавливает текст (регистр, ё→е, знаки в коды, без пробелов), шифрует Атбаш, разбивает результат на группы по 5 символов и возвращает строку в верхнем регистре для вывода в консоль.
def encrypt_text(text):
    """
    Зашифровать текст по Атбаш.
    Возвращает строку в группах по 5 символов (для вывода в консоль).
    """
    # Создаю словарь знак препинания → код
    punct_codes = create_punctuation_codes()
    # Убираю пробелы, заменяю знаки на коды, ё→е, нижний регистр
    prepared = prepare_text_for_encryption(text, punct_codes)
    # Шифрую подготовленный текст методом Атбаш
    encrypted = encrypt_atbash(prepared, RUS_ALPHABET)
    # Разбиваю шифртекст на группы по 5 символов с пробелами
    grouped = split_into_groups_of_five(encrypted)
    # Возвращаю результат в верхнем регистре (для наглядности в консоли)
    return grouped.upper()


# Выполняет полный цикл расшифрования: убирает пробелы из ввода и переводит в нижний регистр, расшифровывает текст Атбаш, восстанавливает знаки препинания из кодов (тчк→., зпт→, и т.д.) и возвращает читаемую строку.
def decrypt_text(text):
    """
    Расшифровать текст по Атбаш.
    Принимает строку (можно с пробелами между группами).
    Возвращает читаемый текст с восстановленными знаками препинания.
    """
    # Создаю обратный словарь код → знак препинания для восстановления
    code_to_punct = create_code_to_punctuation(create_punctuation_codes())
    # Убираю пробелы из ввода и перевожу в нижний регистр
    text_no_spaces = text.replace(" ", "").lower()
    # Расшифровываю шифртекст методом Атбаш
    decrypted = decrypt_atbash(text_no_spaces, RUS_ALPHABET)
    # Восстанавливаю точки, запятые и др. из кодов (тчк, зпт и т.д.) и возвращаю
    return restore_punctuation_from_codes(decrypted, code_to_punct)
