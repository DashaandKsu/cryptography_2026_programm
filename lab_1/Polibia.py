# Квадрат Полибия 6x6 (лабораторная 1).
# В этом файле я делаю:
# 1) функцию создания квадрата Полибия;
# 2) функцию шифрования текста;
# 3) функцию расшифрования текста;
# 4) маленький пример работы в блоке if __name__ == "__main__".

# Импортирую общие функции для работы с текстом и знаками препинания
from lab_1.atbash import (
    create_punctuation_codes,      # словарь: знак препинания -> трёхбуквенный код
    create_code_to_punctuation,    # обратный словарь: код -> знак препинания
    prepare_text_for_encryption,   # подготовка текста к шифрованию
    split_into_groups_of_five,     # разбиение шифртекста на группы по 5 символов
    restore_punctuation_from_codes # восстановление знаков препинания из кодов
)


# Алфавит для квадрата Полибия:
# 32 русские буквы без "ё" + ещё 4 символа (цифры 0,1,2,3),
# всего 36 символов = 6 строк * 6 столбцов.
POLYBIUS_ALPHABET = "абвгдежзийклмнопрстуфхцчшщъыьэюя0123"


def create_polybius_square():
    """
    Создание квадрата Полибия 6x6.
    Возвращает список из 6 списков, в каждом по 6 символов.
    """
    # Пустой список для строк квадрата
    square = []
    # Всего будет 6 строк
    for row_index in range(6):
        # Пустая строка (список) для символов этой строки
        row = []
        # В каждой строке 6 столбцов
        for col_index in range(6):
            # Номер символа в алфавите = номер строки * 6 + номер столбца
            position = row_index * 6 + col_index
            # Беру символ из строки POLYBIUS_ALPHABET по найденной позиции
            symbol = POLYBIUS_ALPHABET[position]
            # Добавляю символ в текущую строку
            row.append(symbol)
        # Когда строка заполнена 6 символами, добавляю её в квадрат
        square.append(row)
    # Возвращаю готовый квадрат 6x6
    return square


def _find_symbol_position(square, symbol):
    """
    Внутренняя функция.
    Ищет символ в квадрате и возвращает (номер_строки, номер_столбца) от 1 до 6.
    Если символ не найден, возвращает (0, 0).
    """
    # Перебираю строки квадрата
    for i in range(6):
        # Перебираю столбцы в одной строке
        for j in range(6):
            # Если символ квадрата совпал с тем, что я ищу
            if square[i][j] == symbol:
                # Возвращаю номера строки и столбца, начиная с 1
                return i + 1, j + 1
    # Если символ не нашёлся в квадрате, возвращаю (0, 0)
    return 0, 0


def _get_symbol_by_position(square, row, col):
    """
    Внутренняя функция.
    Получает символ из квадрата по номерам строки и столбца (от 1 до 6).
    Если номера неправильные, возвращает пустую строку.
    """
    # Проверяю, что номера в допустимых пределах
    if row < 1 or row > 6 or col < 1 or col > 6:
        return ""
    # Перевожу в индексы Python (начинаются с 0)
    i = row - 1
    j = col - 1
    # Возвращаю символ из квадрата
    return square[i][j]


def encrypt_text(text):
    """
    Зашифровать текст методом квадрата Полибия.
    1) Подготовка текста (нижний регистр, ё->е, знаки препинания в коды, без пробелов).
    2) Каждую букву и символ из нашего алфавита заменяем на две цифры: номер строки и столбца.
    3) Разбиваем результат на группы по 5 символов для красивого вывода в консоль.
    """
    # Создаю словарь для замены знаков препинания на коды (., -> "тчк" и т.д.)
    punct_codes = create_punctuation_codes()
    # Готовлю текст к шифрованию (нижний регистр, без пробелов, знаки -> коды)
    prepared_text = prepare_text_for_encryption(text, punct_codes)
    # Создаю квадрат Полибия 6x6
    square = create_polybius_square()
    # Пустая строка, куда буду записывать пары цифр
    encrypted = ""
    # Обрабатываю каждый символ подготовленного текста
    for symbol in prepared_text:
        # Ищу позицию символа в квадрате
        row, col = _find_symbol_position(square, symbol)
        # Если символ есть в нашем алфавите (нашёлся в квадрате)
        if row != 0 and col != 0:
            # Преобразую номера строки и столбца в строку из двух цифр
            encrypted = encrypted + str(row) + str(col)
        else:
            # Если символ не входит в наш алфавит, добавляю его как есть
            encrypted = encrypted + symbol
    # Разбиваю получившуюся строку на группы по 5 символов
    grouped = split_into_groups_of_five(encrypted)
    # Возвращаю результат (можно оставить в виде цифр, верхний/нижний регистр не важен)
    return grouped


def decrypt_text(text):
    """
    Расшифровать текст, зашифрованный квадратом Полибия.
    1) Убираем пробелы из текста (между группами).
    2) Берём по две цифры: первая — номер строки, вторая — номер столбца.
    3) Восстанавливаем символы по квадрату.
    4) Восстанавливаем знаки препинания из кодов (тчк -> ., зпт -> , и т.д.).
    """
    # Создаю словарь код -> знак препинания для восстановления текста
    code_to_punct = create_code_to_punctuation(create_punctuation_codes())
    # Убираю пробелы и перевожу всё в строку без пробелов
    text_no_spaces = text.replace(" ", "")
    # Создаю квадрат Полибия (должен быть такой же, как при шифровании)
    square = create_polybius_square()
    # Пустая строка для записи расшифрованных символов (пока без восстановления знаков)
    decrypted = ""
    # Текущая позиция в строке шифртекста
    position = 0
    # Пока не дошли до конца строки
    while position < len(text_no_spaces):
        # Проверяю, достаточно ли символов для пары цифр (строка + столбец)
        if position + 1 < len(text_no_spaces):
            # Беру две подряд идущие цифры
            first = text_no_spaces[position]
            second = text_no_spaces[position + 1]
            # Проверяю, что обе позиции — цифры от '1' до '6'
            if first in "123456" and second in "123456":
                # Преобразую символы-цифры в целые числа
                row = int(first)
                col = int(second)
                # Получаю символ по этим координатам из квадрата
                symbol = _get_symbol_by_position(square, row, col)
                # Добавляю символ к результату
                decrypted = decrypted + symbol
                # Сдвигаю позицию на 2, потому что обработали две цифры
                position = position + 2
                # Перехожу к следующей итерации цикла while
                continue
        # Если сюда попали, значит либо не хватает символов, либо это не пара цифр
        # В этом случае добавляем один символ как есть и сдвигаем позицию на 1
        decrypted = decrypted + text_no_spaces[position]
        position = position + 1
    # Теперь decrypted содержит буквы и коды знаков препинания (тчк, зпт и т.д.)
    # Восстанавливаю из кодов настоящие знаки препинания
    final_text = restore_punctuation_from_codes(decrypted, code_to_punct)
    # Возвращаю читаемый расшифрованный текст
    return final_text


# Простой пример работы модуля, если запускать этот файл отдельно.
if __name__ == "__main__":
    # Прошу пользователя ввести текст для шифрования
    original_text = input("Введите текст для шифрования квадратом Полибия: ")
    # Шифрую введённый текст
    encrypted_text = encrypt_text(original_text)
    # Печатаю результат шифрования
    print("Зашифрованный текст (группы по 5 символов):", encrypted_text)
    # Теперь сразу расшифровываю полученный шифртекст
    decrypted_text = decrypt_text(encrypted_text)
    # Печатаю расшифрованный текст, чтобы показать, что всё работает
    print("Расшифрованный текст:", decrypted_text)

